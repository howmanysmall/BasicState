{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BasicState \u00b6 BasicState is a really, really simple key-value based state management solution. It makes use of BindableEvents to allow your projects to watch for changes in state, and provides a simple API for communication with your state objects. Think Rodux , but much more simple. Community \u00b6 Special thanks to the contributors of this project! You've made some great improvements and added some awesome features. \ud83d\ude01 Getting Started \u00b6 It's easy to get started using BasicState. There are a few methods to add BasicState to your project: Info It's recommended that you place the BasicState module in a place like ReplicatedStorage , as it can be used on both the client and server; however, this is not mandatory. Method 1: Library \u00b6 The easiest method to add BasicState to your project is via the Toolbox. Grab a copy of the model from the Library page . Insert it into your game via the Toolbox in Roblox Studio. Method 2: Model File \u00b6 Download the latest rbxm or rbxmx file from the Releases page . Insert it into your game via Roblox Studio. Method 3: Rojo \u00b6 Clone the /src directory into your project. Rename the folder to BasicState . Sync it into your game using Rojo . Method 4: Git Submodules \u00b6 Follow the instructions in the following Gist to import a GitHub repo as a submodule. This allows you to link modules into your project, and sync updates when they become available: https://gist.github.com/gitaarik/8735255#adding-a-submodule","title":"Home"},{"location":"#basicstate","text":"BasicState is a really, really simple key-value based state management solution. It makes use of BindableEvents to allow your projects to watch for changes in state, and provides a simple API for communication with your state objects. Think Rodux , but much more simple.","title":"BasicState"},{"location":"#community","text":"Special thanks to the contributors of this project! You've made some great improvements and added some awesome features. \ud83d\ude01","title":"Community"},{"location":"#getting-started","text":"It's easy to get started using BasicState. There are a few methods to add BasicState to your project: Info It's recommended that you place the BasicState module in a place like ReplicatedStorage , as it can be used on both the client and server; however, this is not mandatory.","title":"Getting Started"},{"location":"#method-1-library","text":"The easiest method to add BasicState to your project is via the Toolbox. Grab a copy of the model from the Library page . Insert it into your game via the Toolbox in Roblox Studio.","title":"Method 1: Library"},{"location":"#method-2-model-file","text":"Download the latest rbxm or rbxmx file from the Releases page . Insert it into your game via Roblox Studio.","title":"Method 2: Model File"},{"location":"#method-3-rojo","text":"Clone the /src directory into your project. Rename the folder to BasicState . Sync it into your game using Rojo .","title":"Method 3: Rojo"},{"location":"#method-4-git-submodules","text":"Follow the instructions in the following Gist to import a GitHub repo as a submodule. This allows you to link modules into your project, and sync updates when they become available: https://gist.github.com/gitaarik/8735255#adding-a-submodule","title":"Method 4: Git Submodules"},{"location":"docs/","text":"BasicState.new() \u00b6 Creates a new state object. Accepts an optional InitialState parameter, for defining the state before it is returned. Syntax \u00b6 BasicState.new([ InitialState: Dictionary<any, any> = {} ]): State State:Set() \u00b6 Sets the value of a given key in the state, and then fires off any Changed signals. You should always use this when you need to change the state. Use :RawSet() to change values without invoking change events. Syntax \u00b6 State:Set(Key: any, Value: any): void State:SetState() \u00b6 Set multiple values in the state. Changed signals will be fired for each modified key. Syntax \u00b6 State:SetState(StateTable: Dictionary<any, any>): void Example \u00b6 local State = BasicState . new ({ Location = \"Mountain\" , Greetings = { Place = \"Welcome to the Mountain!\" , Roblox = \"Hey Roblox!\" , Me = \"Hi csqrl!\" } }) State : SetState ({ Location = \"City\" , Greetings = { Place = \"Welcome to the City!\" } }) --[[ The new state object will look like this: { Location = \"City\", Greetings = { Place = \"Welcome to the City!\", Roblox = \"Hey Roblox!\", Me = \"Hi csqrl!\" } } --]] State:Delete() \u00b6 Deletes a key from the store by setting its value to State.None (internally converted to nil ). Syntax \u00b6 State:Delete(Key: any): void Example \u00b6 local State = BasicState . new ({ Hello = \"World\" }) State : Delete ( \"Hello\" ) print ( State : Get ( \"Hello\" )) --> nil State:Toggle() \u00b6 Toggles a stored Boolean value between true and false . Will throw an error if the stored value is not a Boolean. Syntax \u00b6 State:Toggle(Key: any): void Example \u00b6 local State = BasicState . new ({ MenuOpen = false }) State : Toggle ( \"MenuOpen\" ) --> true State : Toggle ( \"MenuOpen\" ) --> false State:Increment() \u00b6 Increases the value of a stored numeric value by 1 (or a specified amount), with an optional cap parameter, which will stop incrementing above a specified number. Will throw an error is the stored value is not a number. Syntax \u00b6 State:Increment(Key: any[, Amount: Number = 1][, Cap: Number = nil]): void State:Decrement() \u00b6 Decreases the value of a stored numeric value by 1 (or a specified amount), with an optional cap parameter, which will stop decrementing below a specified number. Will throw an error if the stored value is not a number. Syntax \u00b6 State:Decrement(Key: any[, Amount: Number = 1][, Cap: Number = nil]): void Example \u00b6 local State = BasicState . new ({ Money = 100 }) local function BuyItem ( ItemName , ItemPrice ) -- A cap of 0 was specified to prevent Money from going below 0 State : Decrement ( \"Money\" , ItemPrice , 0 ) print ( string.format ( \"Bought %s for %d\" , ItemName , ItemPrice )) end BuyItem ( \"Noodles\" , 12 ) State:RawSet() \u00b6 Sets a value in the store without firing any .Changed (or :GetChangedSignal ) events. :RawSet() will also ignore the value of ProtectType , so be careful when dealing with type-sensitive data. Syntax \u00b6 State:RawSet(Key: any, Value: any): void State:Get() \u00b6 Retrieves a value stored in the state. If DefaultValue is specified, it will return that if the entry does not exist (or is equal to nil ). Syntax \u00b6 State:Get(Key: any[, DefaultValue: any = nil]): any State:GetState() \u00b6 Returns the full state object. A new table is returned, rather than a reference to the internal state object. This prevents directly overwriting the state. You should always use the :Set() method if you wish to mutate state. Syntax \u00b6 State:GetState(): Dictionary<any, any> State:GetChangedSignal() \u00b6 Returns an RBXScriptSignal which is only fired when the value of the specified key is updated. The Event fires with the following values (in order): Name Type Description NewValue any The new value of the requested entry. OldValue any The value of the entry prior to mutation. OldState Dictionary<any, any> The entire state object prior to mutation. Syntax \u00b6 State:GetChangedSignal(Key: any): RBXScriptSignal Example \u00b6 local State = BasicState . new ({ Hello = \"World\" }) State : GetChangedSignal ( \"Hello\" ): Connect ( function ( NewValue , OldValue , OldState ) print ( OldValue ) --> \"World\" print ( NewValue ) --> \"Roblox\" end ) State : Set ( \"Hello\" , \"Roblox\" ) State:Destroy() \u00b6 Clears the current state and disconnects all connections. Syntax \u00b6 State:Destroy(): void State:Roact() \u00b6 Wraps a Roact component and injects BasicState into the component's state. Experimental This feature is experimental! You may encounter bugs when using it; if so, please submit an issue . Syntax \u00b6 State:Roact(Component: Roact.Component[, Keys: any[] = nil]): Roact.Component Example \u00b6 There's a full example within the /examples directory on how to use BasicState with Roact: examples/roact-wrapped-counter . State.Changed \u00b6 An RBXScriptSignal which is fired any time the state mutates. The Event fires with the following values (in order): Warning Using :GetChangedSignal() is the preferred method for listening to state changes. Name Type Description OldState Dictionary<any, any> The entire state object prior to mutation. Key any The key of the entry which has mutated. Syntax \u00b6 State.Changed: RBXScriptSignal Example \u00b6 local State = BasicState . new ({ Hello = \"World\" }) State . Changed : Connect ( function ( OldState , Key ) print ( Key ) --> \"Hello\" print ( OldState [ Key ]) --> \"World\" print ( State : Get ( Key )) --> \"Roblox\" end ) State : Set ( \"Hello\" , \"Roblox\" ) State.ProtectType \u00b6 A boolean value which determines whether strict type-checking is enabled on the state table. This prevents changing the type of stored data, e.g. from a number to a string. This is disabled by default. To enable type-safety, simply set this property to true after initialising a new BasicState instance: State.ProtectType = true . Using :RawSet() will ignore type-checking. Syntax \u00b6 State.ProtectType: boolean Example \u00b6 local State = BasicState . new ({ Hello = \"World\" }) State . ProtectType = true State : Set ( \"Hello\" , 1234 ) --> Will throw an error: A string was expected, but it received a number. State.None \u00b6 Lua is unable to determine whether a value in a table is nil or undefined , and removes nil values from tables as a result. State.None is designed to stand in to enable you to remove keys from the state object, which was previously impossible without. It can be used directly with :Set , :SetState or :RawSet , or by using :Delete to remove a single key. Syntax \u00b6 State.None: userdata Example \u00b6 State : Delete ( \"Hello\" ) State : SetState ({ Hello = State . None , })","title":"Documentation"},{"location":"docs/#basicstatenew","text":"Creates a new state object. Accepts an optional InitialState parameter, for defining the state before it is returned.","title":"BasicState.new()"},{"location":"docs/#syntax","text":"BasicState.new([ InitialState: Dictionary<any, any> = {} ]): State","title":"Syntax"},{"location":"docs/#stateset","text":"Sets the value of a given key in the state, and then fires off any Changed signals. You should always use this when you need to change the state. Use :RawSet() to change values without invoking change events.","title":"State:Set()"},{"location":"docs/#syntax_1","text":"State:Set(Key: any, Value: any): void","title":"Syntax"},{"location":"docs/#statesetstate","text":"Set multiple values in the state. Changed signals will be fired for each modified key.","title":"State:SetState()"},{"location":"docs/#syntax_2","text":"State:SetState(StateTable: Dictionary<any, any>): void","title":"Syntax"},{"location":"docs/#example","text":"local State = BasicState . new ({ Location = \"Mountain\" , Greetings = { Place = \"Welcome to the Mountain!\" , Roblox = \"Hey Roblox!\" , Me = \"Hi csqrl!\" } }) State : SetState ({ Location = \"City\" , Greetings = { Place = \"Welcome to the City!\" } }) --[[ The new state object will look like this: { Location = \"City\", Greetings = { Place = \"Welcome to the City!\", Roblox = \"Hey Roblox!\", Me = \"Hi csqrl!\" } } --]]","title":"Example"},{"location":"docs/#statedelete","text":"Deletes a key from the store by setting its value to State.None (internally converted to nil ).","title":"State:Delete()"},{"location":"docs/#syntax_3","text":"State:Delete(Key: any): void","title":"Syntax"},{"location":"docs/#example_1","text":"local State = BasicState . new ({ Hello = \"World\" }) State : Delete ( \"Hello\" ) print ( State : Get ( \"Hello\" )) --> nil","title":"Example"},{"location":"docs/#statetoggle","text":"Toggles a stored Boolean value between true and false . Will throw an error if the stored value is not a Boolean.","title":"State:Toggle()"},{"location":"docs/#syntax_4","text":"State:Toggle(Key: any): void","title":"Syntax"},{"location":"docs/#example_2","text":"local State = BasicState . new ({ MenuOpen = false }) State : Toggle ( \"MenuOpen\" ) --> true State : Toggle ( \"MenuOpen\" ) --> false","title":"Example"},{"location":"docs/#stateincrement","text":"Increases the value of a stored numeric value by 1 (or a specified amount), with an optional cap parameter, which will stop incrementing above a specified number. Will throw an error is the stored value is not a number.","title":"State:Increment()"},{"location":"docs/#syntax_5","text":"State:Increment(Key: any[, Amount: Number = 1][, Cap: Number = nil]): void","title":"Syntax"},{"location":"docs/#statedecrement","text":"Decreases the value of a stored numeric value by 1 (or a specified amount), with an optional cap parameter, which will stop decrementing below a specified number. Will throw an error if the stored value is not a number.","title":"State:Decrement()"},{"location":"docs/#syntax_6","text":"State:Decrement(Key: any[, Amount: Number = 1][, Cap: Number = nil]): void","title":"Syntax"},{"location":"docs/#example_3","text":"local State = BasicState . new ({ Money = 100 }) local function BuyItem ( ItemName , ItemPrice ) -- A cap of 0 was specified to prevent Money from going below 0 State : Decrement ( \"Money\" , ItemPrice , 0 ) print ( string.format ( \"Bought %s for %d\" , ItemName , ItemPrice )) end BuyItem ( \"Noodles\" , 12 )","title":"Example"},{"location":"docs/#staterawset","text":"Sets a value in the store without firing any .Changed (or :GetChangedSignal ) events. :RawSet() will also ignore the value of ProtectType , so be careful when dealing with type-sensitive data.","title":"State:RawSet()"},{"location":"docs/#syntax_7","text":"State:RawSet(Key: any, Value: any): void","title":"Syntax"},{"location":"docs/#stateget","text":"Retrieves a value stored in the state. If DefaultValue is specified, it will return that if the entry does not exist (or is equal to nil ).","title":"State:Get()"},{"location":"docs/#syntax_8","text":"State:Get(Key: any[, DefaultValue: any = nil]): any","title":"Syntax"},{"location":"docs/#stategetstate","text":"Returns the full state object. A new table is returned, rather than a reference to the internal state object. This prevents directly overwriting the state. You should always use the :Set() method if you wish to mutate state.","title":"State:GetState()"},{"location":"docs/#syntax_9","text":"State:GetState(): Dictionary<any, any>","title":"Syntax"},{"location":"docs/#stategetchangedsignal","text":"Returns an RBXScriptSignal which is only fired when the value of the specified key is updated. The Event fires with the following values (in order): Name Type Description NewValue any The new value of the requested entry. OldValue any The value of the entry prior to mutation. OldState Dictionary<any, any> The entire state object prior to mutation.","title":"State:GetChangedSignal()"},{"location":"docs/#syntax_10","text":"State:GetChangedSignal(Key: any): RBXScriptSignal","title":"Syntax"},{"location":"docs/#example_4","text":"local State = BasicState . new ({ Hello = \"World\" }) State : GetChangedSignal ( \"Hello\" ): Connect ( function ( NewValue , OldValue , OldState ) print ( OldValue ) --> \"World\" print ( NewValue ) --> \"Roblox\" end ) State : Set ( \"Hello\" , \"Roblox\" )","title":"Example"},{"location":"docs/#statedestroy","text":"Clears the current state and disconnects all connections.","title":"State:Destroy()"},{"location":"docs/#syntax_11","text":"State:Destroy(): void","title":"Syntax"},{"location":"docs/#stateroact","text":"Wraps a Roact component and injects BasicState into the component's state. Experimental This feature is experimental! You may encounter bugs when using it; if so, please submit an issue .","title":"State:Roact()"},{"location":"docs/#syntax_12","text":"State:Roact(Component: Roact.Component[, Keys: any[] = nil]): Roact.Component","title":"Syntax"},{"location":"docs/#example_5","text":"There's a full example within the /examples directory on how to use BasicState with Roact: examples/roact-wrapped-counter .","title":"Example"},{"location":"docs/#statechanged","text":"An RBXScriptSignal which is fired any time the state mutates. The Event fires with the following values (in order): Warning Using :GetChangedSignal() is the preferred method for listening to state changes. Name Type Description OldState Dictionary<any, any> The entire state object prior to mutation. Key any The key of the entry which has mutated.","title":"State.Changed"},{"location":"docs/#syntax_13","text":"State.Changed: RBXScriptSignal","title":"Syntax"},{"location":"docs/#example_6","text":"local State = BasicState . new ({ Hello = \"World\" }) State . Changed : Connect ( function ( OldState , Key ) print ( Key ) --> \"Hello\" print ( OldState [ Key ]) --> \"World\" print ( State : Get ( Key )) --> \"Roblox\" end ) State : Set ( \"Hello\" , \"Roblox\" )","title":"Example"},{"location":"docs/#stateprotecttype","text":"A boolean value which determines whether strict type-checking is enabled on the state table. This prevents changing the type of stored data, e.g. from a number to a string. This is disabled by default. To enable type-safety, simply set this property to true after initialising a new BasicState instance: State.ProtectType = true . Using :RawSet() will ignore type-checking.","title":"State.ProtectType"},{"location":"docs/#syntax_14","text":"State.ProtectType: boolean","title":"Syntax"},{"location":"docs/#example_7","text":"local State = BasicState . new ({ Hello = \"World\" }) State . ProtectType = true State : Set ( \"Hello\" , 1234 ) --> Will throw an error: A string was expected, but it received a number.","title":"Example"},{"location":"docs/#statenone","text":"Lua is unable to determine whether a value in a table is nil or undefined , and removes nil values from tables as a result. State.None is designed to stand in to enable you to remove keys from the state object, which was previously impossible without. It can be used directly with :Set , :SetState or :RawSet , or by using :Delete to remove a single key.","title":"State.None"},{"location":"docs/#syntax_15","text":"State.None: userdata","title":"Syntax"},{"location":"docs/#example_8","text":"State : Delete ( \"Hello\" ) State : SetState ({ Hello = State . None , })","title":"Example"},{"location":"example/","text":"Tab Highlighting \u00b6 This is a direct extract from the avatar editor UI controller in Bloxikins World. BasicState is being used to control which tab is currently in focus and which asset category to display to players. -- Reference the tab buttons UI container local Tabs = script . Parent . TabButtons -- Create a new BasicState object with the category preset to \"HAT\" local State = BasicState . new ({ Category = \"HAT\" }) -- Update the tabs when the \"Category\" property changes State : GetChangedSignal ( \"Category\" ): Connect ( function ( NewCategory ) -- Iterate through each tab button in the container for _ , TabButton in next , Tabs : GetChildren () do -- Ignore any UI elements which are not ImageButtons if not TabButton : IsA ( \"ImageButton\" ) then continue end -- If the TabButton's Name matches the new value of Category, then it should -- be selected local Selected = TabButton . Name == NewCategory -- If Selected == true, set the button to yellow; otherwise make it white TabButton . ImageColor3 = Selected and Color3 . fromRGB ( 255 , 170 , 0 ) or Color3 . fromRGB ( 235 , 235 , 235 ) end --[[ This function has been truncated for the sake of this example. The full source code for this method also updates the displayed assets in the avatar editor UI. --]] end ) -- Iterate through the children of the TabButton container for _ , TabButton in next , Tabs : GetChildren () do -- Ignore Instances which are not ImageButtons if not TabButton : IsA ( \"ImageButton\" ) then continue end -- If the TabButton's Name is not uppercase, then ignore it if TabButton . Name ~= TabButton . Name : upper () then continue end -- Listen for taps and clicks on the TabButton TabButton . MouseButton1Click : Connect ( function () -- Set Category to the name of TabButton on click State : Set ( \"Category\" , TabButton . Name ) end ) end","title":"Examples"},{"location":"example/#tab-highlighting","text":"This is a direct extract from the avatar editor UI controller in Bloxikins World. BasicState is being used to control which tab is currently in focus and which asset category to display to players. -- Reference the tab buttons UI container local Tabs = script . Parent . TabButtons -- Create a new BasicState object with the category preset to \"HAT\" local State = BasicState . new ({ Category = \"HAT\" }) -- Update the tabs when the \"Category\" property changes State : GetChangedSignal ( \"Category\" ): Connect ( function ( NewCategory ) -- Iterate through each tab button in the container for _ , TabButton in next , Tabs : GetChildren () do -- Ignore any UI elements which are not ImageButtons if not TabButton : IsA ( \"ImageButton\" ) then continue end -- If the TabButton's Name matches the new value of Category, then it should -- be selected local Selected = TabButton . Name == NewCategory -- If Selected == true, set the button to yellow; otherwise make it white TabButton . ImageColor3 = Selected and Color3 . fromRGB ( 255 , 170 , 0 ) or Color3 . fromRGB ( 235 , 235 , 235 ) end --[[ This function has been truncated for the sake of this example. The full source code for this method also updates the displayed assets in the avatar editor UI. --]] end ) -- Iterate through the children of the TabButton container for _ , TabButton in next , Tabs : GetChildren () do -- Ignore Instances which are not ImageButtons if not TabButton : IsA ( \"ImageButton\" ) then continue end -- If the TabButton's Name is not uppercase, then ignore it if TabButton . Name ~= TabButton . Name : upper () then continue end -- Listen for taps and clicks on the TabButton TabButton . MouseButton1Click : Connect ( function () -- Set Category to the name of TabButton on click State : Set ( \"Category\" , TabButton . Name ) end ) end","title":"Tab Highlighting"}]}